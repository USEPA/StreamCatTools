#' @title Get LakeCat data
#'
#' @description
#' Function to return LakeCat metrics using the StreamCat API.  The function allows a user to get
#' specific metric data aggregated by area of interest, returned by comid(s), hydroregion(s), state(s), or county(ies).
#'
#' @author
#' Marc Weber
#'
#' @param metric Name(s) of metrics to query
#' Syntax: name=<name1>,<name2>
#'
#' @param aoi Specify the area of interest described by a metric. By default, all available areas of interest
#' for a given metric are returned.
#' Syntax: areaOfInterest=<value1>,<value2>
#' Values: catchment|watershed|
#'
#' @param comid Return metric information for specific COMIDs.  Needs to be a character string
#' and function will convert to this format if needed.
#' Syntax: comid=<comid1>,<comid2>
#'
#' @param showAreaSqKm Return the area in square kilometers of a given area of interest.
#' The default value is false.
#' Values: true|false
#'
#' @param showPctFull Return the pctfull for each dataset. The default value is false.
#' Values: true|false
#'
#' @param countOnly Return a CSV containing only the row count (ROWCOUNT) and the column
#' count (COLUMNCOUNT) that the server expects to return in a request. The default value is false.
#' Values: true|false
#'
#' @return A tibble of desired StreamCat metrics
#'
#' @examples
#' \donttest{
#' df <- lc_get_data(comid='23794487', aoi='cat', metric='fert')
#'
#' df <- lc_get_data(metric='pcturbmd2006', aoi='ws',
#' comid='24083377')
#'
#' df <- lc_get_data(metric='pctgrs2006', aoi='ws', region='Region01')
#' 
#' df <- lc_get_data(metric='pctwdwet2006', aoi='ws', county='41003')
#' 
#' df <- lc_get_data(metric='pcturb,d2006', aoi='ws',
#' comid='24083377', showAreaSqKm=FALSE, showPctFull=TRUE)
#'
#' df <- lc_get_data(metric='pcturbmd2006,damdens',
#' aoi='cat,ws', comid='23783629,23794487,23812618')
#'
#' df <- lc_get_data(metric='pcturbmd2006,damdens',
#' aoi='cat,ws', comid='23783629,23794487,23812618',
#' countOnly=TRUE)
#' 
#' df <- lc_get_data(comid='23783629', aoi='ws', metric='all')
#'
#'  }
#' @export

lc_get_data <- function(comid = NULL,
                        metric = NULL,
                        aoi = NULL,
                        showAreaSqKm = NULL,
                        showPctFull = NULL,
                        state = NULL,
                        county = NULL,
                        region = NULL,
                        conus = NULL,
                        countOnly = NULL) {
  # Base API URL.
  req <- httr2::request('https://api.epa.gov/StreamCat/lakes/metrics')
  # Collapse comids into a single string separated by a comma.
  if (!is.null(comid))
    comid <- paste(comid, collapse = ",")
  # Force old and odd naming convention to behave correctly
  if (!is.null(aoi)){
    if (aoi == 'catchment') aoi <- 'cat'
    if (aoi == 'watershed') aoi <- 'ws'
  }
  if ((is.null(comid) & is.null(state) & is.null(county) & is.null(region) & is.null(conus)) | is.null(metric) |is.null(aoi)){
    stop('Must provide at a minimum valid comid, metric and aoi to the function')
  }
  if (!is.null(conus) & metric=='all'){
    stop('If you are requesting all metrics please request for regions, states or counties rather than all of conus')
  } 
  if (metric=='all'){
    metrics <- lc_get_params(param='metric_names')
    var_info <- lc_get_params(param='variable_info')
    test <- aoi
    var_info <- var_info |> 
      dplyr::filter(grepl(test, tolower(var_info$aoi)))
    var_met <- tolower(unlist(strsplit(var_info$metric,"\\[.*\\]" )))
    patterns <- c(as.character(1984:2025))
    clean_vector <- stringr::str_remove_all(metrics, paste(patterns, collapse = "|")) 
    pattern <- tolower(stringr::str_remove_all(metrics, paste(patterns, collapse = "|")))[tolower(stringr::str_remove_all(metrics, paste(patterns, collapse = "|"))) %in% var_met]
    pattern <- unique(pattern)
    
    pattern_regex <- paste0("^(", paste(pattern, collapse = "|"), ")", collapse = "")
    
    # Filter metrics 
    selected <- metrics[stringr::str_detect(metrics, stringr::regex(pattern_regex, ignore_case = TRUE))]
    # temporary workaround for a mystery metric
    selected <- selected[!selected=="pctburnarea1984"]
    selected <- selected[!duplicated(selected)]
    metric1 <- paste(selected[1:450], collapse=",")
    metric2 <- paste(selected[451:length(selected)], collapse=",")
    df1 <- req |>
      httr2::req_method("POST") |>
      httr2::req_headers(comid=comid,aoi=aoi,name=metric1,showareasqkm=showAreaSqKm,
                         showpctfull=showPctFull,state=state,county=county,region=region,
                         conus=conus,countOnly=countOnly) |>
      httr2::req_method("POST") |>
      httr2::req_throttle(rate = 30 / 60) |> 
      httr2::req_retry(backoff = ~ 5, max_tries = 3) |>  
      httr2::req_perform() |> 
      httr2::resp_body_string() |> 
      jsonlite::fromJSON()
    df2 <- req |>
      httr2::req_method("POST") |>
      httr2::req_headers(comid=comid,aoi=aoi,name=metric2,showareasqkm=showAreaSqKm,
                         showpctfull=showPctFull,state=state,county=county,region=region,
                         conus=conus,countOnly=countOnly) |>
      httr2::req_method("POST") |>
      httr2::req_throttle(rate = 30 / 60) |> 
      httr2::req_retry(backoff = ~ 5, max_tries = 3) |>  
      httr2::req_perform() |> 
      httr2::resp_body_string() |> 
      jsonlite::fromJSON()
    # Return a data frame
    if (is.null(countOnly)){
      df1 <- df1$items  |> 
        dplyr::select(comid, dplyr::everything())
      df2 <- df2$items  |> 
        dplyr::select(comid, dplyr::everything()) 
      repeat_fields <- names(df2)[names(df2) %in% names(df1)]
      repeat_fields <- repeat_fields[repeat_fields!='comid']
      df2 <- df2[,!(names(df2) %in% repeat_fields)]
      df <- dplyr::left_join(df1, df2)  
      return(df)
    } else return(df1$items)
  } else {
    items = unlist(strsplit(metric,','))
    items = gsub(" ","",items)
    items = gsub("\n","",items)
    params <- sc_get_params(param='metric_names')
    if (!all(items %in% params)){
      stop("One or more of the provided metric names do not match the expected metric names in StreamCat.  Use sc_get_params(param='name') to list valid metric names for StreamCat")
    }
    df <- req |>
      httr2::req_method("POST") |>
      httr2::req_headers(comid=comid,aoi=aoi,name=metric,showareasqkm=showAreaSqKm,
                         showpctfull=showPctFull,state=state,county=county,region=region,
                         conus=conus,countOnly=countOnly) |>
      httr2::req_method("POST") |>
      httr2::req_throttle(rate = 30 / 60) |> 
      httr2::req_retry(backoff = ~ 5, max_tries = 3) |>  
      httr2::req_perform() |> 
      httr2::resp_body_string() |> 
      jsonlite::fromJSON()
    # Return a data frame
    if (is.null(countOnly)){
      df <- df$items  |> 
        dplyr::select(comid, dplyr::everything())
      return(df)
    } else return(df$items)
  }
  
}

#' @title Get NLCD Data
#'
#' @description
#' Function to specifically retrieve all NLCD metrics for a given year using the StreamCat API.
#'
#' @author
#' Marc Weber
#'
#' @param year Years(s) of NLCD metrics to query.
#' Only valid NLCD years are accepted (i.e. 2001, 2004, 2006, 2008,
#' 2011, 2013, 2016, 2019)
#' Syntax: year=<year1>,<year2>
#'
#' @param aoi Specify the area of interest described by a metric. By default, all available areas of interest
#' for a given metric are returned.
#' Syntax: areaOfInterest=<value1>,<value2>
#' Values: catchment|watershed|riparian_catchment|riparian_watershed|other
#'
#' @param comid Return metric information for specific COMIDs
#' Syntax: comid=<comid1>,<comid2>
#'
#' @param showAreaSqKm Return the area in square kilometers of a given area of interest.
#' The default value is false.
#' Values: true|false
#'
#' @param showPctFull Return the pctfull for each dataset. The default value is false.
#' Values: true|false
#'
#' @param countOnly Return a CSV containing only the row count (ROWCOUNT) and the column
#' count (COLUMNCOUNT) that the server expects to return in a request. The default value is false.
#' Values: true|false
#'
#' @return A tibble of desired StreamCat metrics
#'
#' @examples
#' \donttest{
#'
#' df <- lc_nlcd(comid='23783629', year='2019', aoi='ws')
#'
#' df <- lc_nlcd(year='2016', aoi='cat',
#' comid='23783629,23794487,23812618', showAreaSqKm=FALSE, showPctFull=TRUE)
#'
#' df <- lc_nlcd(year='2016', aoi='cat',
#' comid='23783629,23794487,23812618', countOnly=TRUE)
#'
#' df <- lc_nlcd(year='2016, 2019', aoi='cat,ws',
#' comid='23783629,23794487,23812618')
#' }
#' @export


lc_nlcd <- function(year = '2019', aoi = NULL, comid = NULL,
                    showAreaSqKm = NULL, showPctFull = NULL,
                    countOnly = NULL) {
  # year must be a character string.
  year_chr <-  as.character(year)
  # split multiple years supplied as a single string into
  # a vector of years.
  year_vec <- unlist(strsplit(x = year_chr,
                              split = ",|, "))
  # Vector of valid NLCD years to check inputs against.
  valid_years <- c('2001',
                   '2004',
                   '2006',
                   '2008',
                   '2011',
                   '2013',
                   '2016',
                   '2019')
  # Stop early if any of the year(s) supplied are not found in the valid
  # years vec.
  stopifnot(
    "year must be a valid NLCD land cover year: 2001, 2004,
         2006, 2008, 2011, 2013, or 2019" = any(year_vec %in% valid_years)
  )
  # Vector of NLCD metric names.
  nlcd <- c(
    'pctmxfst',
    'pctow',
    'pctshrb',
    'pcturbhi',
    'pcturblo',
    'pcturbmd',
    'pcturbop',
    'pctwdwet',
    'pctbl',
    'pctconif',
    'pctcrop',
    'pctdecid',
    'pctgrs',
    'pcthay',
    'pcthbwet',
    'pctice'
  )
  # Create a data frame of all NLCD Metric and year combinations.
  all_comb <- expand.grid(nlcd, year_vec)
  # Concatenate the NLCD metric name with the supplied year(s) to create
  # valid metric names to submit to the API.
  nlcd_mets <- paste0(all_comb$Var1,
                      all_comb$Var2,
                      collapse = ",",
                      recycle0 = TRUE)
  # Query the API.
  final_df <- lc_get_data(
    metric = nlcd_mets,
    aoi = aoi,
    comid = comid,
    showAreaSqKm = showAreaSqKm,
    showPctFull = showPctFull,
    countOnly = countOnly
  )
  # End of function. Return a data frame.
  return(final_df)
}
